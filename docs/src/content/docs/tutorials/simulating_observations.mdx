---
title: Simulating Observations
description: Tutorial on simulating GRB observations to determine detection times.
---

import {Aside, Steps, Tabs, TabItem} from "@astrojs/starlight/components";

## Objective

This tutorial demonstrates how to simulate observations of time-varying sources to determine if and when they can be detected by CTA. For comprehensive details about exposure calculations, see the [Exposure Time Calculations Guide](/getting_started/exposure).

## Prerequisites

- IRF loaded (see [Loading IRFs](./loading_irfs))
- Sensitivity curve computed (see [Calculating Sensitivity](./calculating_sensitivity))
- Source spectrum loaded (see [Spectral Models](/getting_started/spectral_models))

## Basic Observation Simulation

The `Source.observe()` method simulates an observation starting at a specified delay time:

```python
from sensipy.ctaoirf import IRFHouse
from sensipy.sensitivity import Sensitivity
from sensipy.source import Source
from astropy import units as u

# Setup (IRF, source, sensitivity)
house = IRFHouse(base_directory="./IRFs/CTAO")
irf = house.get_irf(site="south", configuration="alpha", zenith=20,
                     duration=1800, azimuth="average", version="prod5-v0.1")

from sensipy.util import get_data_path
mock_data_path = get_data_path("mock_data/GRB_42_mock.csv")

source = Source(filepath=str(mock_data_path),
                min_energy=20*u.GeV, max_energy=10*u.TeV, ebl="franceschini")

sens = Sensitivity(irf=irf, observatory="ctao_south",
                           min_energy=20*u.GeV, max_energy=10*u.TeV, radius=3.0*u.deg)
sens.get_sensitivity_curve(source=source)

# Simulate observation starting 30 minutes after the GW event
result = source.observe(
    sensitivity=sens,
    start_time=30 * u.min,
    min_energy=20 * u.GeV,
    max_energy=10 * u.TeV,
)

# Display results
if result['seen']:
    print(f"✓ Detectable!")
    print(f"  Observation time: {result['obs_time']}")
    print(f"  Start: {result['start_time']}")
    print(f"  End: {result['end_time']}")
else:
    print(f"✗ Not detectable")
    print(f"  Reason: {result.get('error_message')}")
```

## Testing Multiple Delays

Scan over different observation delays to find the optimal strategy:

<Tabs>
  <TabItem label="Simple Loop">
    ```python
    import numpy as np
    import astropy.units as u

    # Test different delay times
    delays = [10, 30, 100, 300, 1000, 3000] * u.s

    for delay in delays:
        result = source.observe(
            sensitivity=sens,
            start_time=delay,
            min_energy=20 * u.GeV,
            max_energy=10 * u.TeV,
        )

        if result['seen']:
            print(f"Delay {delay:>7}: obs_time = {result['obs_time']}")
        else:
            print(f"Delay {delay:>7}: NOT DETECTABLE")
    ```

  </TabItem>
  
  <TabItem label="With Visualization">
    ```python
    import numpy as np
    import astropy.units as u
    import matplotlib.pyplot as plt

    # Logarithmic scan from 10s to 3 hours
    delays = np.logspace(1, np.log10(10800), 30) * u.s
    obs_times = []
    detectable = []

    for delay in delays:
        result = source.observe(
            sensitivity=sens,
            start_time=delay,
            min_energy=20 * u.GeV,
            max_energy=10 * u.TeV,
        )

        if result['seen']:
            obs_times.append(result['obs_time'].to(u.s).value)
            detectable.append(True)
        else:
            obs_times.append(np.nan)
            detectable.append(False)

    # Plot
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 10))

    # Observation time vs delay
    ax1.loglog(delays.value, obs_times, 'o-', markersize=6)
    ax1.set_xlabel("Delay from Event [s]")
    ax1.set_ylabel("Required Observation Time [s]")
    ax1.set_title("Detection Time vs. Observation Delay")
    ax1.grid(True, alpha=0.3)

    # Detectability map
    colors = ['red' if not d else 'green' for d in detectable]
    ax2.scatter(delays.value, [1]*len(delays), c=colors, s=100, alpha=0.6)
    ax2.set_xscale('log')
    ax2.set_xlabel("Delay from Event [s]")
    ax2.set_yticks([])
    ax2.set_title("Detectability (Green = Detectable, Red = Not Detectable)")
    ax2.grid(True, axis='x', alpha=0.3)

    plt.tight_layout()
    plt.show()
    ```

  </TabItem>
</Tabs>

## Understanding Results

The `observe()` method returns a dictionary with detection information:

```python
{
    'seen': bool,                    # True if detectable
    'obs_time': Quantity,            # Required exposure time
    'start_time': Quantity,          # Observation start (= delay)
    'end_time': Quantity,            # End time (start + obs_time)
    'ebl_model': str,                # EBL model name or None
    'min_energy': Quantity,          # Energy range used
    'max_energy': Quantity,
    # Plus source metadata if available (id, coordinates, distance, etc.)
}
```

## Next Steps

- See the [Exposure Time Calculations Guide](/getting_started/exposure) for:
  - Finding optimal observation windows
  - Batch processing multiple events
  - Advanced parameters (precision control, max time limits, photon flux mode)
  - Understanding the algorithm
  - Troubleshooting tips
- Use [Followup Analysis](./followup_analysis) for fast lookup-based calculations
- Check the [Source API Reference](/reference/source) for full documentation
