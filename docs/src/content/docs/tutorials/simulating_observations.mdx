---
title: Simulating Observations
description: Simulating GRB observations to determine detection times.
---

import {Aside, Steps, Tabs, TabItem} from "@astrojs/starlight/components";

## Objective

Learn how to simulate observations of time-varying sources to determine if and when they can be detected by CTA.

## Prerequisites

- IRF loaded
- Sensitivity curve computed
- Source spectrum loaded

## Basic Observation Simulation

The `Source.observe()` method simulates an observation starting at a specified delay time:

```python
from sensipy.ctaoirf import IRFHouse
from sensipy.sensitivity import SensitivityGammapy
from sensipy.source import Source
from astropy import units as u

# Setup (IRF, source, sensitivity)
house = IRFHouse(base_directory="./CTA-IRFs")
irf = house.get_irf(site="south", configuration="alpha", zenith=20,
                     duration=1800, azimuth="average", version="prod5-v0.1")

source = Source(filepath="data/mock_data/GRB_42_mock.csv",
                min_energy=20*u.GeV, max_energy=10*u.TeV, ebl="franceschini")

sens = SensitivityGammapy(irf=irf, observatory="ctao_south",
                           min_energy=20*u.GeV, max_energy=10*u.TeV, radius=3.0*u.deg)
sens.get_sensitivity_curve(grb=source)

# Simulate observation starting 30 minutes after the GW event
result = source.observe(
    sensitivity=sens,
    start_time=30 * u.min,
    min_energy=20 * u.GeV,
    max_energy=10 * u.TeV,
)

# Display results
if result['seen']:
    print(f"✓ Detectable!")
    print(f"  Observation time: {result['obs_time']}")
    print(f"  Start: {result['start_time']}")
    print(f"  End: {result['end_time']}")
else:
    print(f"✗ Not detectable")
    print(f"  Reason: {result.get('error_message')}")
```

##Testing Multiple Delays

Scan over different observation delays to find the optimal strategy:

<Tabs>
  <TabItem label="Simple Loop">
    ```python
    import numpy as np
    import astropy.units as u

    # Test different delay times
    delays = [10, 30, 100, 300, 1000, 3000] * u.s

    for delay in delays:
        result = source.observe(
            sensitivity=sens,
            start_time=delay,
            min_energy=20 * u.GeV,
            max_energy=10 * u.TeV,
        )

        if result['seen']:
            print(f"Delay {delay:>7}: obs_time = {result['obs_time']}")
        else:
            print(f"Delay {delay:>7}: NOT DETECTABLE")
    ```

  </TabItem>
  
  <TabItem label="With Visualization">
    ```python
    import numpy as np
    import astropy.units as u
    import matplotlib.pyplot as plt

    # Logarithmic scan from 10s to 3 hours
    delays = np.logspace(1, np.log10(10800), 30) * u.s
    obs_times = []
    detectable = []

    for delay in delays:
        result = source.observe(
            sensitivity=sens,
            start_time=delay,
            min_energy=20 * u.GeV,
            max_energy=10 * u.TeV,
        )

        if result['seen']:
            obs_times.append(result['obs_time'].to(u.s).value)
            detectable.append(True)
        else:
            obs_times.append(np.nan)
            detectable.append(False)

    # Plot
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 10))

    # Observation time vs delay
    ax1.loglog(delays.value, obs_times, 'o-', markersize=6)
    ax1.set_xlabel("Delay from Event [s]")
    ax1.set_ylabel("Required Observation Time [s]")
    ax1.set_title("Detection Time vs. Observation Delay")
    ax1.grid(True, alpha=0.3)

    # Detectability map
    colors = ['red' if not d else 'green' for d in detectable]
    ax2.scatter(delays.value, [1]*len(delays), c=colors, s=100, alpha=0.6)
    ax2.set_xscale('log')
    ax2.set_xlabel("Delay from Event [s]")
    ax2.set_yticks([])
    ax2.set_title("Detectability (Green = Detectable, Red = Not Detectable)")
    ax2.grid(True, axis='x', alpha=0.3)

    plt.tight_layout()
    plt.show()
    ```

  </TabItem>
</Tabs>

## Finding Optimal Observation Window

Find the delay that minimizes observation time:

```python
import numpy as np
import astropy.units as u

delays = np.logspace(1, 4, 50) * u.s
optimal_delay = None
min_obs_time = np.inf * u.s

for delay in delays:
    result = source.observe(
        sensitivity=sens,
        start_time=delay,
        min_energy=20 * u.GeV,
        max_energy=10 * u.TeV,
    )

    if result['seen'] and result['obs_time'] < min_obs_time:
        min_obs_time = result['obs_time']
        optimal_delay = delay

if optimal_delay:
    print(f"Optimal observation strategy:")
    print(f"  Wait {optimal_delay.to(u.min):.1f} after event")
    print(f"  Then observe for {min_obs_time.to(u.min):.1f}")
    total_time = optimal_delay + min_obs_time
    print(f"  Total time from event: {total_time.to(u.min):.1f}")
else:
    print("Source not detectable at any tested delay")
```

## Batch Processing Multiple Events

Process many events from a catalog:

```python
from pathlib import Path
import pandas as pd
import astropy.units as u

# Catalog of GRB files
grb_files = list(Path("./catalog/").glob("cat05_*.csv"))[:10]  # First 10

delay = 30 * u.min
results_list = []

for i, grb_file in enumerate(grb_files):
    print(f"Processing {i+1}/{len(grb_files)}: {grb_file.name}")

    source = Source(
        filepath=str(grb_file),
        min_energy=20 * u.GeV,
        max_energy=10 * u.TeV,
        ebl="franceschini"
    )

    sens.get_sensitivity_curve(grb=source)
    result = source.observe(
        sensitivity=sens,
        start_time=delay,
        min_energy=20 * u.GeV,
        max_energy=10 * u.TeV,
    )

    # Add file info
    result['filename'] = grb_file.name
    results_list.append(result)

# Convert to DataFrame
df = pd.DataFrame(results_list)

# Summary statistics
n_detectable = df['seen'].sum()
print(f"\nSummary:")
print(f"  Total events: {len(df)}")
print(f"  Detectable: {n_detectable} ({n_detectable/len(df)*100:.1f}%)")

if n_detectable > 0:
    median_obs = df[df['seen']]['obs_time'].apply(lambda x: x.to(u.min).value).median()
    print(f"  Median obs time (detectable): {median_obs:.1f} min")

# Save results
df.to_csv("observation_results.csv", index=False)
```

## Advanced Parameters

### Precision Control

```python
# High precision (slower, more accurate)
result = source.observe(
    sensitivity=sens,
    start_time=30 * u.min,
    target_precision=0.1 * u.s,  # Precise to 0.1s
    min_energy=20 * u.GeV,
    max_energy=10 * u.TeV,
)

# Low precision (faster)
result = source.observe(
    sensitivity=sens,
    start_time=30 * u.min,
    target_precision=10 * u.s,  # Precise to 10s
    min_energy=20 * u.GeV,
    max_energy=10 * u.TeV,
)
```

### Maximum Time Limit

```python
# Only consider observations up to 2 hours
result = source.observe(
    sensitivity=sens,
    start_time=30 * u.min,
    max_time=2 * u.h,  # Don't search beyond 2 hours
    min_energy=20 * u.GeV,
    max_energy=10 * u.TeV,
)

if not result['seen']:
    print(f"Not detectable within {2 * u.h}")
```

### Photon Flux Mode

```python
# Use photon flux instead of energy flux
result = source.observe(
    sensitivity=sens,
    start_time=30 * u.min,
    sensitivity_mode="photon_flux",  # Alternative mode
    min_energy=20 * u.GeV,
    max_energy=10 * u.TeV,
)
```

## Interpreting Results

The result dictionary contains:

```python
{
    # Detection info
    'seen': bool,                    # True if detectable
    'obs_time': Quantity,            # Required exposure time
    'start_time': Quantity,          # Observation start (= delay)
    'end_time': Quantity,            # End time (start + obs_time)

    # Configuration
    'min_energy': Quantity,          # Energy range used
    'max_energy': Quantity,
    'ebl_model': str,                # EBL model name or None

    # Source metadata (if available)
    'id': int,                       # Event ID
    'long' / 'lat': Quantity,        # Coordinates
    'eiso': Quantity,                # Isotropic energy
    'dist': Quantity,                # Distance
    'angle': Quantity,               # Jet angle

    # Error info
    'error_message': str,            # If not detectable
}
```

## Troubleshooting

**Problem**: All sources report as not detectable

**Solution**:

- Verify energy ranges match between source, sensitivity, and observe()
- Try without EBL first to check if absorption is too strong
- Increase `max_time` parameter
- Check source flux is reasonable

---

**Problem**: Observation times are unrealistically short/long

**Solution**:

- Verify spectral model units (should be cm⁻² s⁻¹ GeV⁻¹)
- Check IRF loading is correct
- Ensure sensitivity was calculated for this source

## Next Steps

- Use [Followup Analysis](./followup_analysis) for fast lookup-based calculations
- See [Exposure Calculations](/getting_started/exposure) for algorithm details
- Check [Source API Reference](/reference/source) for full documentation
